rem package components.db

rem /**
rem * DataProvider
rem *
rem * 
rem * @version 1.0
rem */

use com.basiscomponents.db.DataRow
use java.util.HashMap
use ::components/bl/BusinessComponent.bbj::BusinessComponent
use ::admin/admin.bbj::Admin
use ::admin/admin.bbj::UserCredentials

class public DataProvider

    field private   BBjVector           ResultSet!                 = new BBjVector()
    field private   BBjVector           LastPrepareResultSet! 
    field private   BBjNumber           RecordCountInResultSet
    field protected BBjString           SQL$
    field protected BBjString           DataSource$
    field protected BBjString           Schema$
    field protected BBjString           SchemaPfx$    
    field private   BBjVector           PrimaryKeySegments!        = new BBjVector()
    field private   BBjString           PrimaryTable$

    field protected BBjString           SortField$
    field protected BBjNumber           SortAscending
    field protected BBjString           FulltextFilter$
    field protected BBjVector           FulltextFilterFields!       = new BBjVector()
    field private   BBjNumber           IsBBjTextSearch             = -1             
    field private   HashMap   QueryFilter!
    field private   HashMap   ControllerFilter!           = new HashMap()
    field private   HashMap   ControllerFilterUnlock!     = new HashMap()
    field private   HashMap   QueryConditions!            = new HashMap()

    field private   BBjNumber           Size                        =-1
    field protected BusinessComponent   BC!
    field protected java.sql.Connection Connection!
    field protected java.sql.ResultSet  JDBCResultSet!
    field protected BBjString           ConnMode$
    field public    DataRow             EntityClass!                = new DataRow()
    field private   DataRow             AttributesRecord!   
    field private   DataRow             PrimaryTableLayout!   
    field private   DataRow             QueryLayout!
        
    field private java.util.ArrayList   ColNames!
    field private java.util.ArrayList   ColLabels!
    field private java.util.ArrayList   ColTypes!

    rem set to 1 if the SQL engine does not support the COUNT and you need to go to the last record in the resultset
    field protected BBjNumber FallbackCount
    
    rem /**
    rem * Method setBC:
    rem * register a businesscomponent to receive callback calls
    rem * @param BusinessComponent bc!: the business component linked with this data provider
    rem */
    method public void setBC(BusinessComponent bc!)
        #BC!= bc!
    methodend

    rem /**
    rem * Method addPrimaryKeySegment:
    rem * add a primary key segment
    rem * @param BBjString fieldName$: the name of the primary key segment
    rem */
    method public void addPrimaryKeySegment(BBjString fieldName$)

        #PrimaryKeySegments!.addItem(fieldName$)

    methodend


    rem /**
    rem * Method getPrimaryKeySegments:
    rem * get a BBjVector with the primary key segments
    rem * @return BBjVector keySegments!: the vetor containing the primary key segments
    rem */
    method public BBjVector getPrimaryKeySegments()

        methodret #PrimaryKeySegments!

    methodend


    rem /**
    rem * Method setPrimaryTable:
    rem * set the name of the primary table
    rem * @param BBjString primaryTable$: the name of the primary table
    rem */
    method public void setPrimaryTable(BBjString primaryTable$)

        #PrimaryTable$ = primaryTable$

    methodend


    rem /**
    rem * Method getPrimaryTable:
    rem * get the name of the primary table
    rem * @return BBjString primaryTable$: the name of the primary table
    rem */
    method public BBjString getPrimaryTable()

        methodret #PrimaryTable$

    methodend


    rem /**
    rem * Method setEntityClass:
    rem * set the entity class
    rem * @param DataRow entity!: the entity for the data provider
    rem */
    method public void setEntityClass(DataRow dr!)

        #EntityClass! = dr!

    methodend


    rem /**
    rem * Method getNewEntity:
    rem * get a new entity based on the current result set
    rem * @return DataRow entity!: the new entity based on the current result set
    rem */
    method public DataRow getNewEntity()

        methodret #getAttributesRecord().clone()

    methodend


    rem /**
    rem * Method buildSQLStatement:
    rem * build and return the sql query (filter and order by clausel are ignored)
    rem * @return BBjString sqlQuery$: the sql query
    rem */
    method protected BBjString buildSQLStatement()

        methodret #buildSQLStatement(0)

    methodend


    rem /**
    rem * Method buildSQLStatement:
    rem * build and return the sql query
    rem * @param BBjNumber fIgnoreFilterAndOrder: 1 = ignore filter and order by
    rem * @return BBjString sqlQuery$: the sql query
    rem */
    method protected BBjString buildSQLStatement(BBjNumber fIgnoreFilterAndOrder)

        sql$=#getSQL()

        filter! = new HashMap()

        if fIgnoreFilterAndOrder then
            if #ControllerFilter! = null() then
                filter! = new HashMap()
            else
                filter! = #ControllerFilter!.clone()
            fi
        else
                filter! = new HashMap()

                declare BBjVector allKeys!
                allKeys! = new BBjVector()
                
                if #ControllerFilter! <>null() then
                    ks! = #ControllerFilter!.keySet()
                    it! = ks!.iterator()
                    while it!.hasNext()
                        allKeys!.addItem(it!.next())
                    wend  
                fi  

                if #QueryFilter!<>null() then
                    ks! = #QueryFilter!.keySet()
                    it! = ks!.iterator()
                    while it!.hasNext()
                        k$=it!.next()
                        if allKeys!.contains(k$)=0  then
                            allKeys!.addItem(k$)
                        fi
                    wend    
                fi
                
                it! = allKeys!.iterator()
                while it!.hasNext()
                    k$=it!.next()

                    if #ControllerFilterUnlock!.get(k$)<> null() or #ControllerFilter!=null() then
                        cf! = new BBjVector()
                    else
                        cf! = #ControllerFilter!.get(k$)
                        if cf! = null() then
                            cf! = new BBjVector()
                        fi
                    fi                    
                    
                    if #QueryFilter! = null() then
                        qf! = new BBjVector()
                    else
                        qf! = #QueryFilter!.get(k$)
                        if qf! = null() then
                            qf! = new BBjVector()
                        fi                        
                    fi

                    if qf!.size()>cf!.size() then
                        left! = qf!
                        right! = cf!
                    else
                        left! = cf!
                        right! = qf!
                    fi
      

                    f! = new BBjVector()
                    it1! = left!.iterator()
                    while it1!.hasNext()
                        k1$=it1!.next()
                        if right!.contains(k1$) =0 then
                            f!.addItem(k1$)
                        fi
                    wend

                    filter!.put(k$,f!)
                wend 
       
        fi


        wh$=""
        
        if  filter!<>null() and filter!.size() then
            
            ks!=filter!.keySet()
            it! = ks!.iterator()

            while it!.hasNext()
                k$=it!.next()
                f! = filter!.get(k$)
                w1$=""
                if f!.size() > 0 then
                    for i=0 to f!.size()-1
                        f1$=f!.getItem(i)

                        if pos("%"=f1$)>0 then
                            eq$=" LIKE "
                        else
                            eq$=" = "
                        fi

                        if w1$>"" then
                            w1$=w1$+" OR "
                        fi

                        rem wh$=wh$ + k$ + eq$ + "'"+f1$+"'"
                        w1$=w1$ + k$+ eq$ + "'"+f1$+"'"
                        rem search case insensitive?
                        rem introduce option (set per column, or like Google?)
                        rem or leave it to the database setup?
                    next
                    
                    if w1$>"" then
                        if wh$>"" then
                            wh$=wh$+" AND "
                        fi
                        wh$=wh$+"("+w1$+")"
                    fi                    
                    
                fi


            wend
        fi

       
        if #FulltextFilter$>"" then 
        
          if #PrimaryTable$="CUSTOMER"  then
              rem bbj text search -> find out if it's a BBj database and if there's a text search enabled  
           
          else 
              if #FulltextFilterFields!.size() then
                  rem naive brute force generic method
                  tf$=cvs(#FulltextFilter$,4)
                  it! = #FulltextFilterFields!.iterator()
                  while it!.hasNext()
                      f$ = it!.next()
                      if wh1$>"" then
                          wh1$=wh1$+" OR "
                      fi
                      wh1$=wh1$+"( UCASE("""+f$+""") LIKE '%"+tf$+"%')" 
                  wend
                  if wh$>"" then
                      wh$=wh$+" AND "
                  fi
                  wh$=wh$+"( "+wh1$+ ") "
              fi
          fi
        fi

        if #QueryConditions!.size() then 
        
                  ks! = #QueryConditions!.keySet()
                  it! = ks!.iterator()
                  while it!.hasNext()
                      f$ = it!.next()
                      qc$=#QueryConditions!.get(f$)
                      if wh1$>"" then
                          wh1$=wh1$+" AND  "
                      fi
                      wh1$=wh1$+"("+qc$+")" 
                  wend
                  
                  if wh$>"" then
                      wh$=wh$+" AND "
                  fi
                  wh$=wh$+"( "+wh1$+ ") "
                  
        fi
        
        if wh$>"" then
            
            w=pos("WHERE"=cvs(sql$,4))

            if w>0 then
                sql$=sql$(1,w+5)+" "+wh$+" AND ("+sql$(w+6)+")"
            else
                if pos("ORDER BY"=cvs(sql$,4))=0 then
                    sql$=sql$ + " WHERE "+wh$
                else
                    sql$=sql$(1,pos("ORDER BY"=cvs(sql$,4))-1)+" WHERE "+wh$+" "+sql$(pos("ORDER BY"=cvs(sql$,4)))
                fi
            fi
        fi


        if #SortField$>"" and fIgnoreFilterAndOrder=0 then
            primrow! = #QueryLayout!.getFieldNames() 
            if primrow!.contains(#SortField$) then       
                orderby$=" ORDER BY "+#SortField$
    
                if #SortAscending=0 then
                    orderby$=orderby$+" DESC"
                fi
    
                w=pos("ORDER BY"=cvs(sql$,4))
    
                if w>0 then
                    sql$=sql$(1,w-1)
                fi
                
                sql$=sql$+orderby$
             fi
        fi

        ? sql$
        clipfromstr 1,sql$
REM         input *

        methodret sql$

    methodend


    rem /**
    rem * Method getResultSet:
    rem * get the result set (a BBjVector with DataRow's).
    rem * Call #prepareResultSet() first to execute the sql query.
    rem * @return BBjVector resultSet: a BBjVector with DataRow elements
    rem */
    method public BBjVector getResultSet()

        methodret #ResultSet!

    methodend


    rem /**
    rem * Method size:
    rem * returns the size of the result set
    rem * @return BBjNumber size: the size of the result set. Returns -1 on empty result set.
    rem */
    method public BBjNumber size()

        if #Size = -1 then
            #openDatabase()
            sql$=#buildSQLStatement()
            count$ = sql$
            
            if pos("1=2" =sql$) = 0 then
                if #FallbackCount=0 then
                    rem TimBB fix für MS SQL Die ORDER BY-Klausel ist in Sichten, Inlinefunktionen, abgeleiteten Tabellen, Unterabfragen und allgemeinen Tabellenausdrücken nur dann gültig, wenn auch TOP oder FROM XML angegeben wird.
                    rem sollte ein order by im Satement sein muss dieses entfernt werden
                    
                    if pos("ORDER BY"= sql$) > 0 then
                        count$ = sql$(1,pos("ORDER BY"= sql$)-1)
                    endif
                    sql$="SELECT COUNT(*) AS COUNT FROM ("+count$+") AS X"
    
                    stmt! = #Connection!.createStatement(java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
                    JDBCResultSet! = cast(java.sql.ResultSet,stmt!.executeQuery(sql$))
                fi
                
                if JDBCResultSet!<>null() and JDBCResultSet!.next() and #FallbackCount=0 then
                    #Size = JDBCResultSet!.getInt("COUNT")
                else
                    #FallbackCount=1
                    declare java.sql.ResultSet JDBCResultSet!  
                    stmt! = #Connection!.createStatement(java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
                    JDBCResultSet! = cast(java.sql.ResultSet,stmt!.executeQuery(count$))
                    JDBCResultSet!.last()
                    #Size =  JDBCResultSet!.getRow()

                fi
            else
                size=-1
            fi

            #closeDatabase()
            
        endif

        methodret #Size

    methodend

    method public void setupTextFilter()

        
            if #IsBBjTextSearch=0 then   
                methodret
            fi
            
            #openDatabase()
            
            f$=#FulltextFilter$
            if pos("*"=f$)=0 and pos("~"=f$)=0 then
                f$="*"+f$+"*"
            fi
            
            sql$="CALL BBJ_SEARCH('"+#PrimaryTable$+"','"+f$+"')" 
            stmt! = #Connection!.createStatement(java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
            #JDBCResultSet! = cast(java.sql.ResultSet,stmt!.executeQuery(sql$,err=nobbjtextsearch))
            #IsBBjTextSearch=1

            k! = #getPrimaryKeySegments()

            if #this!.getQueryFilter() = null() then
                #this!.setQueryFilter(new HashMap())
            fi

            it! = k!.iterator()
            while it!.hasNext()
                k$=it!.next()
                #this!.getQueryFilter().put(k$,new BBjVector())
            wend
            
            while #JDBCResultSet!.next()
                foundone = 1
                it! = k!.iterator()
                while it!.hasNext()
                    k$=it!.next()
                    v$=#JDBCResultSet!.getString(k$)
                    qf! = #this!.getQueryFilter().get(k$)
                    qf!.addItem(v$)
                wend
             
            wend

            #closeDatabase()

            if foundone=0 then
            it! = k!.iterator()
              while it!.hasNext()
                  k$=it!.next()
                    qf! = #this!.getQueryFilter().get(k$)
                    qf!.addItem("noopnevernohits in this query!!!")
              wend 
            fi
            it! = k!.iterator()
            while it!.hasNext()
                k$=it!.next()

            wend            
        
            methodret
            
            nobbjtextsearch:
                #IsBBjTextSearch=0
                
    methodend


    
    rem /**
    rem * Method getPrimaryTableLayout:
    rem * returns an empty DataRow with the sql attributes
    rem * @return DataRow row!: an empty DataRow with the sql attributes
    rem */
    method public DataRow getPrimaryTableLayout()

            if #PrimaryTableLayout! <> null() then
                methodret #PrimaryTableLayout!
            fi
            
            #openDatabase()
    
            md! = #Connection!.getMetaData()
    
            declare auto DataRow row!
            row! = #EntityClass!.newInstance()
    
            JDBCResultSet! = md!.getColumns(null(),#Schema$,#PrimaryTable$,"%")
    
            while JDBCResultSet!.next()
                col_type=JDBCResultSet!.getInt("DATA_TYPE")
                col_name$=JDBCResultSet!.getString("COLUMN_NAME")
    
                if (fieldnames! <> null() AND ! fieldnames!.contains(col_name$)) then 
                    continue
                fi
    
                switch col_type
                    case java.sql.Types.VARCHAR
                    case java.sql.Types.CHAR
                    case java.sql.Types.LONGVARCHAR
                    case java.sql.Types.LONGNVARCHAR
                    case java.sql.Types.NCHAR
                    row!.setFieldValue(col_name$,cast(String,null()))
                    break
                    case java.sql.Types.NVARCHAR 
                        row!.setFieldValue(col_name$,cast(String,null()))
                    break
                    case java.sql.Types.NUMERIC
                    case java.sql.Types.DECIMAL
                    row!.setFieldValue(col_name$,cast(java.math.BigDecimal,null()))
                    break
    
                    case java.sql.Types.REAL
                    case java.sql.Types.DOUBLE
                    case java.sql.Types.FLOAT
                    row!.setFieldValue(col_name$,cast(java.lang.Double,null()))
                    break
    
                    case java.sql.Types.INTEGER
                    case java.sql.Types.SMALLINT
                    case java.sql.Types.TINYINT
                    row!.setFieldValue(col_name$,cast(java.lang.Integer,null()))
                    break
    
                    case 9
                    rem hack to compensate flaw in BBj ODBC driver
                    rem 9=BASIS Date
                    rem reported to jash 21.02.2013 SW
                    case java.sql.Types.DATE
                    row!.setFieldValue(col_name$,cast(java.sql.Date,null()))
                    break
    
                    case 11
                    rem hack for BASIS Timestamp
                    case java.sql.Types.TIMESTAMP
                    row!.setFieldValue(col_name$,cast(java.sql.Timestamp,null()))
                    break
    
                    case java.sql.Types.TIME
                    row!.setFieldValue(col_name$,cast(java.sql.Time,null()))
                    break
    
                    case java.sql.Types.BIT
                    case java.sql.Types.BOOLEAN
                    row!.setFieldValue(col_name$,cast(java.lang.Boolean,null()))
                    break
    
                    case java.sql.Types.BINARY
                    case java.sql.Types.VARBINARY
                    case java.sql.Types.BLOB
                    case java.sql.Types.CLOB
                    case java.sql.Types.LONGVARBINARY
                    rem these types tend to be blobs
                    rem dunno what to do with these TODO
                    rem simply skip...
                    continue
                    break
    
                    case default
                    row!.setFieldValue(col_name$,"")
                    break
                swend
    
                row!.setSQLType(col_name$,col_type)
    
            wend
    
            #closeDatabase()
            
        fi
        #PrimaryTableLayout! = row!
        methodret row!
     
    methodend
    
    
    rem /**
    rem * Method getAttributesRecord:
    rem * returns an empty DataRow with the sql attributes
    rem * @return DataRow row!: an empty DataRow with the sql attributes
    rem */
    method public DataRow getAttributesRecord()

        declare auto BBjVector fieldnames!
        if #AttributesRecord!<> null() then
            methodret #AttributesRecord!
        else
         
        v! = #prepareResultSet(0,0)
        
        if #AttributesRecord! = null() then 
            methodret new DataRow()
        else

            methodret #AttributesRecord!
            
        fi

    methodend


    rem /**
    rem * Method prepareResultSet:
    rem * Execute the SQL query and prepare the result set
    rem * @param BBjNumber first: start reading at the "first" row from the record set
    rem * @param BBjNumber last: read to the "last" row from the record set
    rem * return BBjVector vec!: a BBjVector with the row numbers
    rem */
    method public BBjVector prepareResultSet(BBjNumber first, BBjNumber last)


        if first=0 and last=0 then
            canExit=1
        fi

        if #getResultSet().size()=#Size and #BC!<>null() and #BC!.isPreFiltering() and #LastPrepareResultSet! <> null() then
            methodret new BBjVector()
        fi

        v! = new BBjVector()

        rem JDBC Resultset is not zero-based
        first=max(1,first+1)
        last = last+1
        
        sql$=#buildSQLStatement()
        
        rem now determine size for later use - it's probably needed anyway
        
        if #Size = -1 and canExit=0 then
            #size()
        fi

        if (#Size>-1 and #Size<500) or (#BC!<> null() and #BC!.isPreFiltering()) then
            first=1
            last=#Size
            #ResultSet!.clear()  
        fi
        
        if #SortField$>"" and #QueryLayout! <> null() then
            if ! #QueryLayout!.getFieldNames().contains(#SortField$) then
                first=1
                if #Size>-1 then
                    last=#Size
                fi 
                #ResultSet!.clear()  
            fi
        fi
        

        if pos("1=2"=sql$)=0 then
            #openDatabase()
            stmt! = #Connection!.createStatement(java.sql.ResultSet.TYPE_SCROLL_SENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
            #JDBCResultSet! = cast(java.sql.ResultSet,stmt!.executeQuery(sql$))
            
            jrs! = #JDBCResultSet!
            
            if #RecordCountInResultSet > 500 then
                if #ResultSet!.size() then
                    for i=0 to #ResultSet!.size()-1
                        if i>=first and i<=last then
                            continue
                        fi
                        if #ResultSet!.getItem(i) <> null() 
                            #ResultSet!.setItem(i,null())
                            #RecordCountInResultSet=#RecordCountInResultSet-1
                        fi
                        if #RecordCountInResultSet < 500 then 
                            break
                        fi
                    next
                 fi
            fi

            if jrs!.absolute(first) then
                while #ResultSet!.size() < first-1
                    #ResultSet!.addItem(null())
                wend
                
                VARCHAR         = java.sql.Types.VARCHAR
                CHAR            = java.sql.Types.CHAR
                LONGVARCHAR     = java.sql.Types.LONGVARCHAR
                LONGNVARCHAR    = java.sql.Types.LONGNVARCHAR
                NCHAR           = java.sql.Types.NCHAR                

                
                while 1
                    
                    if #ResultSet!.size()=first+x-1 or #ResultSet!.getItem(first+x-1)=null() then
                        declare auto DataRow row!
                        row! = new DataRow(jrs!)

                        
                        if #QueryLayout!= null() then
                            #QueryLayout! = row!.clone()
                        fi
                        
                        if #AttributesRecord! = null()  and row! <> null() then
                            #AttributesRecord! = row!.clone()
                            if canExit then 
                                methodret null()
                            fi
                            rem this is really ugly, assuming that we can abandon the query with the first
                            rem record as long as #AttributesRecord! is null
                            rem as this is most probably just a prelude of finding out out about the structure of the
                            rem result set
                        fi

                        if #BC! <> null() then
                            
                            row! = #BC!.preProcessRecord(row!)
                            if row! = null() then
                                rem if preProcessRecord returns null,
                                rem then business logic decided to skip this
                                rem record 
                                skew=skew+1
                                goto nextRecord
                            fi
                        fi



                        if #ResultSet!.size()=first+x-1 then
                            #ResultSet!.addItem(row!)
                        else
                            #ResultSet!.setItem(first+x-1,row!)
                        fi
                        #RecordCountInResultSet = #RecordCountInResultSet+1 

                        v!.addItem(first+x-1)
                    fi

                    x=x+1

                 nextRecord:
                    if jrs!.next() then
                        if first+x<=last then
                            continue
                        fi
                    fi

                    break
                wend
            fi

            #Size=#Size-skew 

        else
            v! = new BBjVector()
            #Size = 0
        fi

        #closeDatabase()

        rem now resort the resultset
        rem maybe this needs a more clever place and way in the future
        if #SortField$>"" and #QueryLayout! <> null() then
            if ! #QueryLayout!.getFieldNames().contains(#SortField$)  then
            
                map! = new java.util.TreeMap()
                vec! = #getResultSet()
                it! = vec!.iterator()
                i=0
                ft$ = row!.getFieldType(#SortField$)
                while it!.hasNext()
                    row! = it!.next()
                    rem todo: other data types (num, date)
                    if ft$="N" then
                        s$=str(row!.getFieldAsNumber(#SortField$,err=skip_sorting):"-000000000000000000.00000")
                    else
                        s$=row!.getFieldAsString(#SortField$,err=skip_sorting)
                    fi
                    s$=s$+str(i:"0000000000") 
                    i=i+1
                    if #SortAscending = 1 then
                        s$=#invert(s$)
                    fi
                    map!.put(s$,row!)
                wend

                vec!.clear()
                ks! = map!.keySet()
                it! = ks!.iterator()
                while it!.hasNext()
                    k$=it!.next()
                    vec!.addItem(map!.get(k$))
                wend
                #setResultSet(vec!)
                
                skip_sorting:
            fi
        fi
        
        
        #LastPrepareResultSet! = cast(BBjVector,v!)
        methodret v!

    methodend


    rem /**
    rem * Method getConnMode:
    rem * get the connection mode for the database and cache it for future use
    rem */
    method protected BBjString getConnMode()

        if #ConnMode$="" then
            connect_user! = null()
            connect_pwd! = null()

            rem Get User Authentication Login, if applicable
            user_auth$ = "NO"
            auth_login$ = stbl("!DSUDDB",err=no_user_auth)
            if pos(",passwd="=auth_login$) then
                auth_login$(pos(",passwd="=auth_login$),1)=" "
            endif
            dim auth_tpl$:"LOGIN:C(1):"+auth_login$+":",err=no_user_auth
            auth_user$ = fattr(auth_tpl$,"LOGIN","user",err=no_user_auth)
            auth_passwd$ = fattr(auth_tpl$,"LOGIN","passwd",err=no_user_auth)
            user_auth$ = "YES"
            no_user_auth:

            rem get user credentials
            admin! = new Admin()
            if user_auth$ = "YES" then
                admin!.setUser(auth_user$)
                admin!.setPassword(auth_passwd$)
            endif
            rem admin!.removeUserCredentialsCookie()

            userCredentials! = BBjAPI().getGroupNamespace().getValue("userCredentialsFromCookie",err=*next)
            if  userCredentials! = null() then 
                userCredentials! = admin!.getUserCredentials()
                BBjAPI().getGroupNamespace().setValue("userCredentialsFromCookie",userCredentials! )
            fi

            if (userCredentials! <> null())
                connect_user! = userCredentials!.getUser()
                connect_pwd! = userCredentials!.getPassword()
            else
                goto connectAuthError 
            endif

            connMode$=""
            if connect_user! <> null() and connect_user! <> "" then
                connMode$ = connMode$ + "user=" + connect_user!
            endif
            if connect_pwd! <> null() and connect_pwd! <> "" then
                connMode$ = connMode$ + fill(sgn(len(connMode$)),",") + "password=" + connect_pwd!
            endif

            #ConnMode$ = connMode$
        endif

        methodret #ConnMode$

    methodend


    rem /**
    rem * Method openDatabase:
    rem * open the connection to the database
    rem */
    method protected void openDatabase()

        if #Connection! = null() then
            connMode$=#getConnMode()

            count = 0
            while count < 3
                #Connection! = BBjAPI().getJDBCConnection(#DataSource$,connMode$,err=*next); break
                if err <> 12 then exitto connectError
                count = count + 1
            wend
        endif

        if #Connection! = null() then goto connectError

        methodret


        connectError:
            throw "Could not connect to data source " + #DataSource$,12
            methodret

        connectAuthError:
            throw "Failed to get connection authorization for user " + #DataSource$,12
            methodret

    methodend


    rem /**
    rem * Method closeDatabase:
    rem * close the connection to the database
    rem */
    method protected void closeDatabase()

        if #Connection! <> null() then
            #Connection!.close()
            #Connection! = null()
        fi

    methodend


    rem /**
    rem * Method setSortOrder:
    rem * set the sort order to one column
    rem * @param BBjString col$: the column name
    rem * @param BBjNumber size: 0=descending, 1=ascending
    rem */
    method public void setSortOrder(BBjString col$, BBjNumber sortAscending)

        #SortField$=col$
        #SortAscending = sortAscending

    methodend


    rem /**
    rem * Method setQueryFilter:
    rem * filters the result set
    rem * @param HashMap filter!: a hash map that holds the filter information, key is the column, data is a BBjVector holding the values for the filter
    rem */
    method public void setQueryFilter(HashMap filter!)

        #QueryFilter!=filter!
        #Size=-1

    methodend

    rem /**
    rem * Method addQueryCondition:
    rem * filters the result set by freestyle query conditions on the SQL
    rem * @param BBjString ConditionTag$: a tag under which the business component knows the condition
    rem * @param BBjString Condition$: the condition to be embedded in the SQL where clause
    rem */
    method public void addQueryCondition(BBjString ConditionTag$, BBjString Condition$)

        if Condition$="" then
            #removeQueryCondition(ConditionTag$)
        else
          #QueryConditions!.put(ConditionTag$,Condition$)
          #Size=-1
        fi

    methodend    
    
    rem /**
    rem * Method removeQueryCondition:
    rem * filters the result set by freestyle query conditions on the SQL
    rem * @param BBjString ConditionTag$: a tag under which the business component knows the condition
    rem */
    method public void removeQueryCondition(BBjString ConditionTag$)

        #QueryConditions!.remove(ConditionTag$)
        #Size=-1

    methodend        

    rem /**
    rem * Method setFulltextFilter:
    rem * filters the result set
    rem * @param BBjString filter$: the search query 
    rem */
    method public void setFulltextFilter(BBjString filter$)

        #FulltextFilter$=filter$
        #setupTextFilter()
        #Size=-1

    methodend


    rem /**
    rem * Method setControllerFilterUnlock:
    rem * called to (temporarily) unlock the business component from the UIController driver
    rem * @param BBjString field$: the field to be unlocked
    rem * @param BBjNumber f_unlock: 1=unlock, 0=lock
    rem */
    method public void setControllerFilterUnlock(BBjString field$, BBjNumber f_unlock)

        if f_unlock then
            #ControllerFilterUnlock!.put(field$,1)
        else
            #ControllerFilterUnlock!.remove(field$)
        fi

        #Size=-1

    methodend


    rem /**
    rem * Method putControllerFilter:
    rem * put a filter to the controller
    rem * @param BBjString var$: the variable on which is to be filtered
    rem * @param BBjVector selection!: vector holding list of filter values
    rem */
    method public void putControllerFilter(BBjString var$, BBjVector selection!)

        #ControllerFilter!.put(var$,selection!)
        #Size=-1

    methodend


    rem /**
    rem * Method clearControllerFilter:
    rem * remove a filter from the controller
    rem * @param BBjString var$: the name of the field on which the filter was set
    rem */
    method public void clearControllerFilter(BBjString var$)

        #ControllerFilter!.remove(var$)
        #Size=-1

    methodend

    rem /**
    rem * Method getControllerFilter:
    rem * get controller filter
    rem * @param BBjString var$: the name of the field on which the filter was set
    rem */
    method public HashMap getControllerFilter()

        cf! = #ControllerFilter!.clone()
        methodret cf! 
        
    methodend
    
    rem /**
    rem * Method getDistinctValues:
    rem * returns distinct values in a given column of the resultset
    rem * these values are mainly used for filterin purpose
    rem * @param BBjString fieldName$: the column name for which the distinct values are requested
    rem * @return java.util.TreeMap distinct!: the distinct values
    rem */
    method public java.util.TreeMap getDistinctValues(BBjString fieldName$)

        #openDatabase()

        sql$="SELECT DISTINCT "+fieldName$+" AS D FROM ("+#buildSQLStatement(1)+") AS X"

        stmt! = #Connection!.createStatement(java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
        #JDBCResultSet! = cast(java.sql.ResultSet,stmt!.executeQuery(sql$))
        rem print sql$

        tm! = new java.util.TreeMap()

        while #JDBCResultSet!.next()
            d! = #JDBCResultSet!.getString("D")
            if d! <> null() then
                tm!.put(str(d!),1)
            fi
        wend

        #closeDatabase()

        methodret tm!

    methodend


    rem /**
    rem * Method insertRecord
    rem * inserts a record to the table
    rem * @param DataRow rec!: the fields
    rem */
    method public void insertRecord(DataRow rec!)

        if #PrimaryKeySegments!.size()=0 then
            throw "primary key segments in SQLBusinessComponent not defined!",13
        fi

        if #PrimaryTable$="" then
            throw "primary table in SQLBusinessComponent not defined!",13
        fi


        
        

            cf! = #getControllerFilter()

            if cf!<>null() then
                ks! = cf!.keySet()
                it! = ks!.iterator()

                while it!.hasNext()
                    k$=it!.next()
                    v!=cf!.get(k$)

                    if v!.size() then
                        value$=v!.getItem(0)
                        if !rec!.contains(k$) then
                            rec!.setFieldValue(K$,value$)
                        fi 
                    fi
                wend
            fi
        

        prow! = #getPrimaryTableLayout()
        primrow! = prow!.getFieldNames()
        hm! = rec!.getObjects()

        ks! = hm!.keySet()
        
        it! = ks!.iterator()
        uhm! = new HashMap()

        while it!.hasNext()
            k$=it!.next()
            if primrow!.contains(k$) then 
              s$=s$+","+k$
              v$=v$+",? "
              uhm!.put(k$,hm!.get(k$))
            fi              
        wend

        if len(s$)=0 then
            a=msgbox("nothing to add!"+str(rec!),0,"SQL Error")
            methodret
        fi
        
        s$=s$(2)
        v$=v$(2)

        sql$="INSERT INTO "+#SchemaPfx$+#PrimaryTable$+" ("+s$+") VALUES ("+v$+")"
        rem print sql$


        #openDatabase()
        


        stmt! = #Connection!.prepareStatement(sql$)
        ks! = uhm!.keySet()
        it! = ks!.iterator()
        i=1

        while it!.hasNext()
            k$=it!.next()
            obj!= rec!.getField(k$)
            type$=rec!.getFieldType(k$)
            

            if type$="C" then
                stmt!.setString(i,obj!)
            fi

            if type$="N" then
                stmt!.setDouble(i,obj!)
            fi

            if type$="I" then
                stmt!.setInt(i,obj!)
            fi

            if type$="B" then
                stmt!.setBoolean(i,obj!)
            fi

            if type$="D" then
                stmt!.setDate(i,obj!)
            fi

            if type$="X" then
                stmt!.setTimestamp(i,obj!)
            fi

            if type$="Y" then
                stmt!.setBigDecimal(i,obj!)
            fi

            if type$="T" then
                stmt!.setTime(i,obj!)
            fi

            i=i+1
            
            if wh$>"" then
                wh$=wh$+" AND "
            fi
            wh$=wh$+" ("+k$+"=?) "
        wend

        rem TODO: catch error
        ret=stmt!.executeUpdate(err=*next)

        ? "(",ret,")"
        
        if ret=0 then
            a=msgbox(BBjAPI().getLastJavaException().toString()+" "+sql$+" Line "+str(tcb(5)),0,"Error")
        fi

        
        if ret=1 then
              rem re-read the just added record and put it into the result set on first position 
              rem TODO find a better implementation when the database generates the primary index 
              sql$=#getSQL()
              if pos("WHERE"=cvs(sql$,4))>0 then
                  sql$=sql$(1,pos("WHERE"=cvs(sql$,4))-1)
              fi
              sql$=sql$+" WHERE "+wh$
              
              stmt! = #Connection!.prepareStatement(sql$,java.sql.ResultSet.TYPE_SCROLL_SENSITIVE, java.sql.ResultSet.CONCUR_READ_ONLY)
              
      
              ks! = uhm!.keySet()
              it! = ks!.iterator()
              i=1
      
              while it!.hasNext()
                  k$=it!.next()
                  obj!= rec!.getField(k$)
                  type$=rec!.getFieldType(k$)
      
      
                  if type$="C" then
                      stmt!.setString(i,obj!)
                  fi
      
                  if type$="N" then
                      stmt!.setDouble(i,obj!)
                  fi
      
                  if type$="I" then
                      stmt!.setInt(i,obj!)
                  fi
      
                  if type$="B" then
                      stmt!.setBoolean(i,obj!)
                  fi
      
                  if type$="D" then
                      stmt!.setDate(i,obj!)
                  fi
      
                  if type$="X" then
                      stmt!.setTimestamp(i,obj!)
                  fi
      
                  if type$="Y" then
                      stmt!.setBigDecimal(i,obj!)
                  fi
      
                  if type$="T" then
                      stmt!.setTime(i,obj!)
                  fi
                  i=i+1
              wend
              jrs! = cast(java.sql.ResultSet,stmt!.executeQuery())
              jrs!.beforeFirst() 
              declare java.sql.ResultSet jrs!
             
              #Size=max(#Size,0)
              while jrs!.next(err=skip)
                  r! = new DataRow(jrs!)
                  #ResultSet!.addItem(r!)
                  #Size=#Size+1 
              wend
              skip:
        fi
        #closeDatabase()

        

    methodend


    rem /**
    rem * Method updateRecord
    rem * saves a record within the result set
    rem * @param DataRow rec!: the row
    rem * @param DataRow orig_rec!: the original row
    rem */
    method public void updateRecord(DataRow rec!, DataRow orig_rec!)

        it!=#PrimaryKeySegments!.iterator()
        while it!.hasNext()
            seg$=it!.next()
            if wh$>"" then
                wh$=wh$+" AND "
            fi
            
            v$      = orig_rec!.getFieldAsString(seg$)

            wh$=wh$+" ( "
            wh$=wh$+seg$
            wh$=wh$+" = '"
            wh$=wh$+v$
            wh$=wh$+"' ) "
        wend

        prow! = #getPrimaryTableLayout()
        primrow! = prow!.getFieldNames()
        hm! = rec!.getObjects()

        ks! = hm!.keySet()
        it! = ks!.iterator()
        uhm! = new HashMap()
        
        while it!.hasNext()
            k$=it!.next()
            if primrow!.contains(k$) then 
                s$=s$+", "+k$+" = ? "
                uhm!.put(k$,hm!.get(k$)) 
                prow!.setFieldValue(k$,hm!.get(k$))
            fi
        wend
        
        if len(s$) then
            s$=s$(2)
            sql$="UPDATE "+#SchemaPfx$+#PrimaryTable$+" SET "+s$+" WHERE "+wh$
   
            #openDatabase()
            declare java.sql.PreparedStatement stmt!
    
            stmt! = #Connection!.prepareStatement(sql$)
            i=1
            ks! = uhm!.keySet()
            it! = ks!.iterator()
            
            while it!.hasNext()
                k$=it!.next()
                obj!= prow!.getField(k$)
                type$=prow!.getFieldType(k$)
    
                if type$="C" then
                    stmt!.setString(i,obj!)
                fi
    
                if type$="N" then
                    stmt!.setDouble(i,obj!)
                fi
    
                if type$="I" then
                    stmt!.setInt(i,obj!)
                fi
    
                if type$="B" then
                    stmt!.setBoolean(i,obj!)
                fi
    
                if type$="D" then
                    stmt!.setDate(i,obj!)
                fi
    
                if type$="X" then
                    stmt!.setTimestamp(i,obj!)
                fi
    
                if type$="Y" then
                    stmt!.setBigDecimal(i,obj!)
                fi
    
                if type$="T" then
                    stmt!.setTime(i,obj!)
                fi

                i=i+1

            wend
    
            rem TODO: catch error
            ret=stmt!.executeUpdate(err=*next)
            ? "(",ret,")"
    
            if ret=0 then
                ex! = BBjAPI().getLastJavaException()
    
                if ex! <> null() then
                    a=msgbox(ex!.toString()+" "+sql$+" Line "+str(tcb(5))+" Obj: "+str(obj!),0,"Error")
                fi
            fi
    
            stmt!.close()
            #closeDatabase()
        fi
        
    methodend


    rem /**
    rem * Method deleteRecords
    rem * deletes a record
    rem * @param BBjVector indexList!: a vector with primary key values
    rem */
    method public void deleteRecords(BBjVector indexList!)

        if #PrimaryKeySegments!.size()=0 then
            throw "primary key segments in SQLBusinessComponent not defined!",13
        fi

        if #PrimaryTable$="" then
            throw "primary table in SQLBusinessComponent not defined!",13
        fi

        if indexList!.size()>0 then
            for i=0 to indexList!.size()-1
                row=indexList!.getItem(i)
                row! = #getResultSet().getItem(row)

                if i>0 then
                    wh$=wh$+" OR "
                fi

                wh$=wh$+"("

                for j=0 to #PrimaryKeySegments!.size()-1
                    if j>0 then
                        wh$=wh$+" AND "
                    fi

                    f$=#PrimaryKeySegments!.getItem(j)
                    v$=row!.getFieldAsString(f$)

                    rem wh$=wh$+"TRIM("+f$+")= '"+v$+"'"
                    wh$=wh$+" "+f$+"= '"+v$+"'"
                next j

                wh$=wh$+")"
            next i


            sql$="DELETE FROM "+#PrimaryTable$+" WHERE "+wh$
            rem print sql$

            #openDatabase()
            stmt! = #Connection!.createStatement()
            rem TODO: catch error
            ret=stmt!.executeUpdate(sql$,err=*next)
            ? "(",ret,")"


            if ret=0 then
                a=msgbox(BBjAPI().getLastJavaException().toString(),0,"Error")
                ? sql$
                escape
            fi

            #closeDatabase()
            #Size=-1
        fi

    methodend

    method private BBjString invert(BBjString in$)
        for i=1 to len(in$)
            out$=out$+chr(255-asc(in$(i,1)))
        next
        methodret out$
    methodend

classend
